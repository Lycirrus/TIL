# Python Data Types
## Data Types
값의 종류와 그 값에 적용 가능한 연산과 동작을 결정하는 속성

## Sequence Types
### list
여러 개의 값을 순서대로 저장하는 **<span style ="color:RED">변경 가능한</span>** 시퀀스 자료형
  - 0개 이상의 객체를 포함
  - **대괄호**로 표기
  - 어떠한 자료형도 저장 가능
  
### tuple
여러 개의 값을 순서대로 저장하는 **<span style ="color:RED">변경 불가능한</span>** 시퀀스 자료형
  - 0개 이상의 객체를 포함
  - **소괄호**로 표기
  - 어떠한 자료형도 저장 가능
  - 객체가 하나일 때는 끝에 `,`를 붙여주어야 함
    > `(1)`의 경우 소괄호가 벗겨지며, int형이 된다!!!
    >
    > 실제로 파이썬 코드로 돌려봤을 경우 다음과 같이 나왔다.
    ```python
    print(type((1)))
    # 결과 : <class 'int'>

    print(type((1,)))
    # 결과 : <class 'tuple'>
    ```

  #### tuple의 사용
  - 불변의 특성을 이용해서 개발자가 작성한 코드보다는 **파이썬 내부 동작**에서 주로 사용
  - 안전하게 여러 개의 값을 전달하거나 다중 할당 할 때 사용
    ```python
    x, y = (10, 20)

    print(x) # 10
    print(y) # 20
    ```
  - 파이썬은 콤마를 튜플 생성자로 사용해서 괄호는 생략 가능
    ```python
    x, y = 10, 20
    ```

### range
연속된 정수 시퀀스를 ***생성***하는 **<span style ="color:RED">변경 불가능한</span>** 자료형
  
    > range(시작값, 끝값, 증가량)
  - 증가량이 없으면 1씩 증가
  - 증가량이 음수면 감소하고 양수면 증가
  - 증가량이 음수면 시작값이 끝값보다 커야함
  #### range의 출력
  - range는 print하면 아래와 같이 출력된다
    > range(0, n-1)
  - list()로 리스트 형으로 형변환하면 range 내 정수를 볼 수 있다
    > [0, 1, ... , n-1]

## Non-sequence Types
### dict
key - value 쌍으로 이루어진 `순서와 중복이 없는` **<span style ="color:RED">변경 가능한</span>** 자료형

  - key는 변경 불가능한 자료형만 사용 가능
    > 키는 중복이 되선 안되며, 딕셔너리에서 키를 통해 값에 접근하기 때문에 
    >
    >안전을 위해 변경 불가능한 자료형만 사용한다
  - value는 모든 자료형 사용 가능
  - **중괄호**로 표기
  #### dict의 추가
  ```python
  dict['first'] = 50
  # 출력 : {'first' : 50}
  ```
  #### dict의 변경
  ```python
  dict['first'] = 100
  # 출력 : {'first' : 100}
  ```

  #### dict의 주의사항
  - dict은 순서가 없으므로 인덱스도 없다
  - 오로지 key를 이용해서 value를 찾을 뿐이다

### set
`순서와 중복이 없는` **<span style ="color:RED">변경 가능한</span>** 자료형

  - 집합과 동일한 연산 처리 가능
  - **중괄호**로 표기
    > set와 dict 모두 중괄호 사용
    >
    > 어떻게 구분할까?
    >
    > `a = {}`는 dict
    >
    > 'set()'로 set 생성
  #### set의 집합 연산

  <div align = "center">

  |집합|기호|
  |:--:|:--:|
  |합집합|`\|`|
  |차집합|`-`|
  |교집합|`&`|
  |합집합 - 교집합|`^`|

  </div>

  #### set 주의사항
  - 순서가 있는 자료형을 set로 변경하면 중복은 사라지지만 **순서 역시 사라진다**.

## Other Type
### None
파이썬에서 '값이 없음'을 표현하는 자료형
  - `None`의 맨 앞 N은 대문자로 입력

### Boolean
참(True)과 거짓(False)를 표현하는 자료형
  - 비교 / 논리 연산의 평가 결과로 사용
  - 조건 / 반복문과 함께 사용

## Collection
여러 개의 항목 또는 요소를 담는 자료 구조
  - `str`, `list`, `tuple`, `set`, `dict`을 묶어서 이르는 단어
  
  #### collection 특징 정리
  <div align = "center">

  |Collection|변경 여부|순서 여부|
  |:--------:|:------:|:-------:|
  |str|X|O|
  |list|O|O|
  |tuple|X|O|
  |dict|O|X|
  |set|O|X|

  </div>

  #### 가변과 불변
  - 가변 자료형은 값 자체가 아닌 값이 있는 메모리의 주소를 가진다

## 형변환
한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
  - **암시적**과 **명시적** 형변환 두 가지가 있음
  
  #### 암시적 형변환
  파이썬이 자동으로 수행하는 형변환
  - 정수와 실수의 연산에서 정수가 실수로 자동 변환
  - *Boolean*과 *Numeric Type*에서만 가능
  - 암시적 형변환이 일어나지 않도록 코드를 작성하는 것이 최상

  #### 명시적 형변환
  프로그래머가 직접 지정하는 형변환
  1. `str` > `int`
     - 정수형에 한해서 가능
     - 실수형은 소수점 이하를 버리고 출력
     - 실수형은 `float` 사용
  2. `int` > `str`
     - 모두 가능

## 연산자
### 산술 연산자

<div align = "center">

|기호|의미|
|:--:|:--:|
|`-`|음수 부호|
|`+`|더하기|
|`-`|빼기|
|`*`|곱하기|
|`/`|나누기|
|`//`|몫|
|`%`|나머지|
|`**`|지수|


</div>

### 복합 연산자
연산과 할당을 동시에 진행

<div align = "center">

|기호|예시|의미|
|:--:|:--:|:--:|
|`+=`|a += b|a = a + b|
|`-=`|a -= b|a = a - b|
|`*=`|a *= b|a = a * b|
|`/=`|a /= b|a = a / b|
|`//=`|a //= b|a = a // b|
|`%=`|a %= b|a = a % b|
|`**=`|a **= b|a = a ** b|

</div>

### 비교 연산자

<div align = "center">

|기호|내용|
|:-:|:-:|
|`<`|미만|
|`<=`|이하|
|`>`|초과|
|`>=`|이상|
|`==`|동등|
|`!=`|동등하지 않음|
|`is`|값과 주소가 같음|
|`is not`|값이나 주소가 같지 않음|

</div>

  #### is 비교 연산자
  - `==`는 동등성으로 **값**이 같은지 확인
  - `is`는 식별성으로 **값**에 더불어 **메모리 주소**도 동일해야만 함
  - 보통 Boolean이나 None을 비교할 때 사용
    > `is None`

### 논리 연산자

<div align = "center">

|기호|연산자|내용|
|:-:|:-:|:-:|
|`and`|논리곱|두 피연산자가 모두 True일 때<br>전체를 True로 평가|
|`or`|논리합|두 피연산자 중 하나라도 True일 때<br>전체를 True로 평가|
|`not`|논리부정|단일 피연산자를 부정|

</div>

### 단축평가
논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
  - 평가 도중에 결과가 도출되는 경우
  - 컴퓨터는 코드를 앞에서부터 순차적으로 평가
  - `False and`의 경우나 `True or`의 경우 앞에 결론이 나왔으므로 빠져나옴
  - 결국 코드 실행을 최적화하고, 불필요한 연산을 피하기 위한 목적
    ```python
    # and

    print(3 and 5) == 5
    # 앞의 3(True)만으로는 전체 표현식의 Boolean을 알 수 없으므로 뒤까지 진행
    # 뒤는 5(True)이고 표현식도 True이므로 뒤의 5가 출력

    print(3 and 0) == 0
    # 동일하게 앞의 3(True)만으로 표현식을 판단할 수 없음
    # 뒤에 0(False)이 나와 표현식이 False가 되었으므로 0이 출력

    print(0 and 3) == 0
    # 앞에서 0(False)이 나와 이미 표현식은 False가 되었으므로 중단 ==> 이를 단축평가라 함
    # 0 출력

    print(0 and 0) == 0
    # 위와 동일함. 단축평가
    # 앞의 0(False)에서 판단되었으므로 앞의 0을 출력
    ```
    ```python
    # or

    print(0 or 3) == 3
    # 앞에 0(False)이 나왔지만 표현식의 Boolean이 확정되지 않음
    # 뒤에 False가 나오면 False, True가 나오면 True가 됨
    # 3(True)이 나왔으므로 표현식은 True가 되고, 3이 출력

    print(3 or 0) == 3
    # 앞에서 3(True)이 나왔으므로 표현식은 무조건 True가 될 수 밖에 없음 ==> 단축평가 진행
    # 3이 출력

    print(3 or 5) == 3
    # 위와 동일하므로 단축평가가 진행됨
    # 5를 평가하기 전에 끝났으므로 3이 출력
    ```

### 멤버십 연산자
특정 값이 시퀀스나 다른 컬렉션에 속하는지 여부 확인
  - `in`연산자 뒤에는 컬렉션이 나와야 함
  - 딕셔너리는 `in` 앞에 `key`가 나와야 함

<div align = "center">

|기호|내용|
|:-:|:-:|
|`in`|앞 피연산자가 뒤 시퀀스에 속하는지 확인|
|`not in`|앞 피연산자가 뒤 시퀀스에 속하지 않는지 확인

</div>

### 시퀀스형 연산자

<div align = "center">

|기호|내용|
|:-:|:-:|
|`+`|시퀀스를 결합|
|`*`|시퀀스를 반복|

</div>

## 자체 Q&A
- tuple은 불변성을 가진다. 그러나 `x, y = (1, 2)`로 할당했을 때는 x값을 바꿀 수 있다. 왜 그런가?
  > `t = (1, 2, 3)`이 있을 때, `t[1]`에 새로운 값을 할당할 수 없었다. 이는 튜플이기 때문이다.
  >
  > `a = (1, 3, 4)`를 `a = (1, 2, 3, 8)`로 바꿀 수는 있었다. 이는 a에 할당된 기존 튜플의 주소 대신 새로운 튜플의 주소를 할당했기 때문에 튜플 내부가 바뀐 것은 아니기 때문이다.
  >
  > `x, y = (1, 2)`에서 튜플로 할당은 되지만 x나 y가 튜플은 아니다. 각각 int형의 값이 할당되었으므로 x에 다른 값을 할당할 수 있는 것이다.
<br></br>  
- set 자료형은 key도, 순서도 없는데 어떻게 값을 선택할까?
  > set 자료형은 이런 의문을 가지지 않아도 되는 것 같다.
  >
  > 특정 값을 선택하고 싶으면 list형으로 변환 후 진행하면 될 것이다.
  >
  > set은 순서도 없고 자체적으로 정렬되지도 않는다.
  >
  > 실제로 해봤을 때 중구난방이었다. 개인적으로 여기서 어떠한 규칙성도 찾지 못했다.
  > ```python
  > a = set([1,554,1,3,4,2,-1,50,64646,8,23,31])
  > print(a)
  > # 결과 : {1, 2, 3, 4, 64646, 8, 554, 50, 23, -1, 31}
  > ```
  > 값 자체를 다루기 때문에 요소를 추가하거나 제거할 때도 값 그대로 이용한다. `add` `update` `remove`

## 공부 내용 돌아보기
리스트의 경우 알고리즘 문제를 풀면 거의 반드시 사용해야 하는 자료형이다. 그러나 튜플의 경우는 거의 보지 못했다. 튜플은 변경이 불가하니 쉽게 쓰기는 힘들 것 같다.<br>
기존에 `==`와 `is`는 동일한 줄 알았다. `is`는 보통 `None`과 함께 쓰니 `None`에 대한 특별 연산자거나 관용구라고 생각했다. 그러나 가변 자료형은 값 자체가 아닌 값이 있는 방(메모리)의 주소를 가진다는 것을 알았다. 그리고 이것 때문에 같은 값을 나타내더라도 주소가 다르다면 `==`은 True를 반환하지만, `is`는 False를 반환한다는 것을 알게 되었다.</br>
단축평가는 완전히 처음들어보는 단어였다. 컴퓨터의 사고방식이 인간과는 차이가 있음을 느끼는 부분이었다. 컴퓨터는 계산 순서대로 앞에서부터 처리한다. 앞부분에서 이미 결과가 도출된다면 그대로 답을 출력하고 식에서 빠져나간다. 앞으로 코딩을 할 때, 특히 논리 연산자를 사용할 때 주의해야 하겠다.