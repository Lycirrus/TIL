# Python Function
## 함수
특정 작업을 수행하기 위한 재사용 가능한 코드 묶음
 - 중복을 방지
 - 재사용이 용이해지고, 중복이 줄어들기에 코드의 가독성이 향상
 - 코드 수정시 함수 부분만 수정하면 전체 코드에 영향을 미치므로 보수하기 편리
### 함수 명명법
  #### 함수의 이름
  - 이 함수가 어떤 일을 하는지 알 수 있도록 명명
  - 동사 사용
  #### 함수의 역할
  - 함수는 한가지 역할만 할 수 있도록 구성
### 함수의 구성요소
  ```python
  def make_sum(pram1, pram2):
  # 함수 정의와 입력값(Input)
  # 정의는 def 키워드로 시작한다.
    """
    Docstring => 함수에 대한 설명
    """
    sum_pram = pram1 + pram2
    # 함수 부분(Function Body)
    return sum_pram
    # 반환값(Output)
    # 함수는 return문을 만나면 종료한다.
    # 그러므로 return 이후는 작동하지 않는다.
    # 만약 return이 없다면 `return None`을 파이썬이 자동으로 설정한다.
  ```
### 함수 호출
- 함수를 사용하기 위해서는 호출 필요
- 함수 def 키워드 이후의 함수 이름과 매개변수에 들어갈 인자를 입력하여 호출한다.
- `function_name(arguments)`

### print 함수
- print는 출력이지 반환이 아님
- 그래서 return이 없다!!!
- 따라서 print 함수를 받은 변수를 출력해보면 None이 나온다.
  ```python
  a = 130
  result = print(a) # 130
  result_result = print(result) # None
  ```
- 아래 코드에서는 어떻게 될까?
  ```python
  def my_func():
    print('hello')

  result = my_func()
  print(result)

  # 결과:
  # 먼저 my_func 함수 안의 print가 출력된다.
  # 'hello' 출력
  # 이후 print 출력을 받은 result를 다시 print한다.
  # print를 print 했으므로 'None'이 출력

  # 최종 출력:
  # hello
  # None
  ```

## 매개변수와 인자
### 매개변수 (parameter)
함수를 **<span style = "color: Red">정의</span>** 할 때, 함수가 받을 값을 나타내는 변수

### 인자 (argument)
함수를 **<span style = "color: Red">호출</span>** 할 때, 실제로 전달도는 값

### 인자의 종류
  1. 위치 인자
     - 함수 호출 시 인자의 **위치**에 따라 전달되는 인자
     - <span style = "color: Red">함수 호출 시 반드시 인자를 전달해야 함!!</span>
      ```python
      def greet(name, age):
        print(f'저는 {name}이고, {age}살 입니다.')

      greet('Me', 25)
      # 정상적으로 출력된다.

      greet('Me')
      # age에 해당하는 인자가 전달되지 않았으므로 에러가 발생한다.
      # TypeError 발생

      greet(25, 'Me')
      # 작동된다.
      ```
  2. 기본 인자 값
     - 함수 정의에서 매개변수에 기본 값을 할당하는 것
     - 인자 전달이 없으면 기본값을 할당한다
      ```python
      def greet(name, age = 30):
        print(f'저는 {name}이고, {age}살 입니다.')

      greet('Me', 25)
      # 저는 Me이고, 25살 입니다.
      # 로 출력된다.

      greet('Me')
      # age 기본 값인 30이 출력된다.
      # 저는 Me이고, 30살 입니다.
      ```
  3. 키워드 인자
     - 함수 호출 시 인자의 이름과 함께 값을 전달
     - 인자 순서 상관없이 인자 이름을 명시하여 전달
     - <span style = "color: Red">단, 호출 시 키워드 인자는 위치 인자 뒤에 위치해야 함!!</span>
      ```python
      def greet(name, age):
        print(f'저는 {name}이고, {age}살 입니다.')

      greet(name = 'Me', age = 25)
      # 저는 Me이고, 25살 입니다.
      # 로 출력된다.

      greet(age = 25, name = 'Me')
      # 인자 이름을 명시하여 전달하였기 때문에 위와 동일하게 출력된다.

      greet(age = 25, 'Me')
      # name을 명시하지 않았으므로 오류가 발생한다.
      # SyntaxError 발생
      ```
  4. 임의의 인자 목록
     - 정해지지 않은 개수의 인자를 처리하는 인자
     - 함수 정의 시 매개변수 앞에 `*`를 붙여 사용
     - 여러 개의 인자를 튜플로 처리
       > 시스템에서 자동으로 들어오는 인자를 묶기 때문에 튜플을 이용했다.
     ```python
      def calculate_sum(*args):
        print(args)
        print(type(args))
        total = sum(args)
        print(f"합계 : {total}")

      calculate_sum(1, 2, 3)
      # (1, 2, 3)
      # <class 'tuple'>
      # 합계 : 6

      # 인자를 받은 매개변수 args는 튜플형이다.
      ```
      - <span style = "color: Red">임의의 인자 목록도 위치 인자 뒤에 적어야 한다!!!</span>
  5. 임의의 키워드 인자 목록
     - 정해지지 않은 개수의 키워드 인자를 처리
     - 함수 정의 시 매개변수 앞에 `**`를 붙여 사용
     - 여러 개의 인자를 딕셔너리로 묶어 처리
       > 키워드라는 말에서 보듯이 키를 사용하므로 딕셔너리 형태로 처리한다.
     ```python
     def print_info(**kwargs):
        print(kwargs)

     print_info(name = 'Me', age = 25)
     # 출력
     # {'name': 'Me', 'age': 25}
     ```
  #### 함수 인자 권장 순서
  1. 위치
  2. 기본
  3. 가변
  4. 가변 키워드
   - 다만 절대적인 규칙은 아니다.

## 재귀 함수
함수 내부에서 자기 자신을 호출하는 함수
  - return에 함수 자기 자신을 넣음으로써 만든다.
  - 팩토리얼이나 피보나치 수열과 같은 수열을 만들 때 용이하다.
### 재귀 함수 특징
- 특정 알고리즘 식을 표현할 때, 변수 사용이 줄어들고 그로인해 코드 가독성이 높아진다.
- 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성한다.
### 재귀 함수 사용 이유
- 복잡한 문제를 간결하고 직관적으로 표현하기 위해 사용한다.
- 상황에 따라 반복문보다 코드가 더 간결해진다.
### 주의사항
- 종료 조건을 명확히 한다.
- return 호출이 종료 조건을 향하도록 한다.

## 내장 함수 (Built-in function)
파이썬이 기본적으로 제공하는 함수

<div align = "center">

|종류|기능|
|:-:|:-:|
|`print`|내용 출력|
|`len`|시퀀스나 논시퀀스의<br> 요소 개수|
|`max`|함수 인자 내 최대값|
|`min`|함수 인자 내 최솟값|
|`sum`|함수 인자들의 합계|
|`sorted`|함수 인자 정렬|
</div>

### map과 zip
#### map
`map(function, *iterable)`
- function : 함수
- iterable : 반복 가능한 객체(컬렉션 등)
  > iterable의 요소 하나하나에 function을 적용하는 방식

<br>

- function 자리에 내가 만든 함수도 입력 가능하여 확장성이 뛰어남

#### zip
`zip(*iterables)`
- zip 객체를 리스트로 변환하면 컬렉션들은 열끼리 튜플로 다시 묶인다.
- 2차원 리스트의 같은 열 요소를 동시에 조회할 때 유용하다.

## 함수와 Scope
### Python의 범위
- 함수는 코드 내부에 <span style = "color:Red">local scope (지역)</span>을 생성
- 함수 외의 공간은 <span style = "color:Red">global scope (전역)</span>으로 칭함

### 변수 수명주기
1. built-in scope
   - 파이썬이 실행된 이후부터 영원히 유지
2. global scope
   - 모듈이 호출된 시점 이후 혹은 인터프리터가 끝날 때까지 유지
3. local scope
   - 함수가 호출될 때 생성되고, 종료될 때까지 유지
### 이름 검색 규칙
파이썬은 다음과 같은 순서로 이름을 찾아나간다.
1. Local Scope
2. ~~Enclosed Scope : 지역 범위 한 단계 위 범위~~ [없을 수도 있다.]
3. Global Scope
4. Built-in Scope

- <span style = "color:RED">함수 내에서는 바깥 Scope 변수에 접근 가능하나 수정은 할 수 없음</span>

### global 키워드
- 변수의 스코프를 전역 범위로 지정하기 위해 사용
- 함수 내에서 전역 변수를 수정하고 싶을 때 사용
  #### 주의사항
  - 함수 내에서 global 선언 전에 전역 변수를 사용하면 원하는 대로 작동하지 않음
  - 매개변수에는 global 사용 불가

## Packing & Unpacking
### Packing
- 변수에 여러 개의 값이 할당될 경우 자동으로 **튜플**로 묶임
- `*`는 남는 요소들을 **리스트**로 패킹

### Unpacking
패킹된 변수의 값을 개별적이 변수로 분리하여 할당하는 행위
- 튜플이나 리스트 등의 객체 요소를 개별 변수에 할당
- `*<list>`는 **리스트** 요소를 언패킹하여 인자로 전달
- `**<dict>`은 **딕셔너리** 요소를 언패킹하여 인자로 전달
   > 단, 딕셔너리 언패킹 시 매개변수 명과 key 값을 동일하게 해줘야 한다.

## Lambda expressions
**익명** 함수를 만드는 데 사용되는 표현식
- **한 줄**로 간단한 함수를 정의
- `lambda 매개변수: 표현식`
  - 매개변수는 콤마로 구분

> map과 함께할 때 유용하다.
> ```python
> squared = map(lambda x: x ** 2, numbers)
> ```
> 그리고 람다 함수는 일회성으로 사용하고자 할 때 활용한다.


## 자체 Q%A
- 재귀 함수는 어떠한 순서로 작동할까?
  > 다음은 유명한 팩토리얼 함수이다.
  > ```python
  > def factorial(n):
  >   if n == 1:
  >     return 1
  >   else:
  >     return n * factorial(n - 1)
  > print(factorial(3))
  > ```
  > 함수 인자로 3이 들어갔으니, 함수의 else 부분으로 넘어갈 것이다.<br>
  > 그러나 `3 * factorial(2)`를 바로 계산하는 것이 아니었다.<br>
  > 컴퓨터는 아직 `factorial(2)`의 반환값을 모른다.<br>
  > 그래서 `factorial(1)`까지 즉, **base case**까지 모두 진행한 후 역순으로 값을 반환한다.<br>
  > 그러기에 재귀 함수의 방향이 base case를 향하지 않는다면 무한으로 돌아 컴퓨터에 부하가 돌 것을 추측할 수 있었다.

<br>

- 함수에서 매개변수는 위치 인자 사이에 `*`을 이용하는 임의의 인자 목록을 넣었을 때, 중간 부분의 인자만을 받아오지 못했지만 패킹에서는 `*` 활용하여 리스트의 중간 부분을 패킹할 수 있었다. 둘의 차이는 무엇인가?
  > 함수의 매개변수는 인자를 받을 때, 인자의 위치에 따라 받는 것이 아닌 해당되는 키워드로 전달되는 방식이다.<br>
  > 위치 인자는 매개변수와 1:1로 매칭되기에 키워드가 연결될 뿐이다.<br>
  > 함수 호출 시, 인자의 위치를 파악하지 않기 때문에 키워드 인자로 확실하게 명시해주지 않는다면, `*args`는 중간 부분만이 아닌 키워드가 지정되지 않은 남은 인수를 모두 받는 것이다.<br>
  > 반대로 패킹에서는 요소들을 위치에 따라 나누어주기 때문에 중간 부분의 값만을 받을 수 있는 것이다.

<br>

- map만 사용했을 때는 내부 함수가 작동하지 않고, list로 감싸주었을 때 작동했다. 그러는 이유는 무엇인가?
  > map을 실행하려면 형변환을 하거나 반복문에 입력해야 한다.<br>
  map을 선언하더라도 대기상태로 되어있다고 한다.

## 공부 내용 돌아보기
함수는 반복되는 수식이나 구간을 하나로 단축시킨다는 점에서 매우 매력적이고 훌륭한 도구인 듯 싶다.<br>
함수가 인자를 받는 방식도 여러가지였다. 기본적으로는 위치 인자를 사용하고, 일부 공란이 필요한 리스트 등을 만들 때 기본값 인자를 사용할 것 같다.<br>
인자 목록은 여러 개의 값을 받아 처리할 수 있어 상황에 따라 유용할 것이다.<br>
map은 알고리즘 문제를 풀면 값 입력을 받을 때 항상 쓰던 함수이다. zip 같은 경우는 애매하게 따라썼을 때는 어떤 기능인지 헷갈렸다. 그러나 오늘 2차원 배열을 열순서로 재배열한다고 들으니 이해가 쉽게 되었다. *추가로 새로 생성된 행은 튜플로 생성된다는 것도 확인했다.*