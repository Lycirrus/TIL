# 상속과 예외처리
## 상속
기존 클래스의 속성과 메서드를 물려받아 새로운 하위 클래스를 생성하는 것

  #### 상속이 필요한 이유
  1. 코드 재사용
   - 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
   - 새로운 클래스를 작성할 때 기존 클래스의 기능을 그대로 활용할 수 있으며, 중복 코드를 줄일 수 있음
  2. 계층 구조
   - 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
   - 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음
  3. 유지 보수의 용이성
   - 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
   - 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화할 수 있음
  
### 클래스 상속
  #### 클래스 상속을 사용하는 이유
  - 데이터 그룹 별로 클래스를 생성했을 때 내부 속성 또는 메서드가 겹쳐 중복이 일어날 경우, 이를 방지하기 위하여 사용

  #### 클래스 상속 지정 방법
  `class <자식 class>(<부모 class>)` 

### 다중 상속
둘 이상의 부모 클래스로부터 여러 행동이나 특징을 상속받을 수 있는 것
- 상속받은 모든 클래스의 요소를 활용 가능함
- 중복된 속성이나 메서드가 있는 경우 **상속 순서에 의해 결정**됨
  > 상속 순서는 다음과 같다.
  > ```python
  > class child(dad, mom):
  >   pass
  > ```
  > 의 경우 본인 클래스를 먼저 확인하고, 'dad', 'mom' 순으로 탐색한다.

  #### 다이아몬드 문제
  두 클래스 B와 C가 A에서 상속되고, 클래스 D가 B와 C 모두에서 상속될 때 발생하는 모호함
  - B와 C가 재정의한 메서드가 A에 있고 D가 이를 재정의하지 않은 경우
  - D는 B와 C 중 어떤 버전을 상속하는가?
  
  #### 파이썬에서의 해결
  - MRO *(Method Resolution Order)* 알고리즘 사용
  - 상속 속성들의 검색을 깊이 우선으로 왼쪽에서 오른쪽으로 진행하여 두 번 이상 검색하지 않도록 함
  
  #### MRO
  메서드 결정 순서
  - `super()`<br>부모 클래스 객체를 반환하는 내장 함수
    ```python
    class ParentA:
      def __init__(self):
        self.value_a = 'ParentA'

      def show_value(self):
        print(f'Value from ParentA: {self.value_a}')


    class ParentB:
      def __init__(self):
        self.value_b = 'ParentB'

      def show_value(self):
        print(f'Value from ParentB: {self.value_b}')
    
    class Child(ParentA, ParentB):
      pass
    ```
    > 부모 클래스에 입력했던 메서드 내용을 중복해서 적지 않아도 된다.
    > 'parent B'의 중복 메서드를 사용하기 위해서는 `ParentB.show_value()`처럼 직접 지정해주어야 한다.
    > super는 정의될 때가 아닌 메서드가 호출될 때 작동하여 클래스를 탐색하기 시작한다.
    > 자식 클래스의 인스턴스 변수는 부모 클래스의 영향을 받는다.
    > 상속받지 않은 인스턴스 변수를 호출하면 에러가 발생한다.
    > super 사용시 self 매개변수는 쓰지 않아도 되지만, 탐색된 부모 클래스의 메서드의 매개변수는 모두 입력해주어야 한다.

  - `mro()`
  - 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인하는 메서드
  - 기존의 인스턴스에서 클래스 순으로 이름 공간을 탐색하는 과정에서, 상속관계에 있으면 `인스턴스 > 자식 클래스 > 부모 클래스`로 확장

  #### MRO가 필요한 이유
  - 부모 클래스들이 여러 번 액세스 되지 않도록
    - 탐색 순서를 보존하고
    - 각 부모 클래스를 한 번만 호출하고
    - 부모 우선순위에 영향을 주지 않으면서 서브 클래스를 만드는 단조적인 구조 형성
   > 프로그래밍 언어의 신뢰성과 확장성 제공
   > 클래스 간의 메서드 호출 순서 예측 가능
   > 코드의 재사용성과 유지보수성 향상
  
  #### super의 사용 사례
  1. 단일 상속 구조
   - 특정 부모 클래스를 지정하지 않으므로 코드의 유연성이 증가
  2. 다중 상속 구조
   - MRO를 따른 메서드 호출
   - 복잡한 다중 상속 구조에서 발생할 수 있는 문제 방지

## 에러와 예외
### 디버깅
**버그**<br>소프트웨어에서 발생하는 오류 또는 결함<br>프로그램의 예상된 동작과 실제 동작 사이의 불일치

**디버깅**<br>소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정<br>프로그램의 오작동 원인을 식별하여 수정하는 작업

  #### 디버깅 방법
  1. print 함수 활용
  2. 개발 환경 등에서 제공하는 기능 활용
  3. Python tutor 활용
  4. 뇌 컴파일, 눈 디버깅 등

### 에러
프로그램 실행 중에 발생하는 예외 상황

<div align = "center">

|문법에러|예외|
|:-----:|:--:|
|프로그램의 구문이 올바르지 않은 경우 발생|프로그램 실행 중에 감지되는 에러|
</div>

### 예외
프로그램 실행 중에 감지되는 에러

  #### 내장 예외
  예외 상황을 나타내는 예외 **클래스**들
  - 파이썬에서 이미 정의되어 있음
  - 특정 예외 상황에 대한 처리를 위해 사용

  1. `ZeroDivisionError` : 나누기 또는 모듈로 연산의 두 번째 인자가 0일 때 발생
  2. `NameError` : 지역 또는 전역 이름을 찾을 수 없을 때 발생
  3. `TypeError` : 연산 시 타입이 불일치하거나 인자가 초과 혹은 누락, 인자의 타입이 불일치할 때 발생
  4. `ValueError` : 연산이나 함수에 문제가 없지만 부적절한 값을 가진 인자를 받았고, 더 구체적인 예외로 설명되지 않는 경우 발생
  5. `IndexError` : 시퀀스 인덱스가 범위를 벗어날 때 발생
  6. `KeyError` : 딕셔너리에 해당 키가 존재하지 않는 경우
  7. `ModuleNotFoundError` : 모듈을 찾을 수 없을 때 발생
  8. `ImportError` : from으로 모듈을 부른 후 import 하려는 이름을 찾을 수 없을 때 발생
  9. `KeyboardInterrupt` : 사용자가 'Ctrl + C' 또는 'Delete'를 누를 때 발생
  10. `IndentationError` : 잘못된 들여쓰기와 관련된 문법 오류

## 예외 처리
예외가 발생했을 때 프로그램이 비정상적으로 종료되지 않고, 적절하게 처리할 수 있도록 하는 방법

  #### 예외 처리 사용 구문
  - `try` : 예외가 발생할 수 있는 코드 작성
  - `except` : 예외가 발생했을 때 실행할 코드 작성
  - `else` : 예외가 발생하지 않았을 때 실행할 코드 작성
  - `finally` : 예외 발생 여부와 상관없이 항상 실행할 코드 작성

### try & except
  #### try-except 구조
  - try 블록 안에는 예외가 발생할 가능성이 있는 코드 작성
  - except 블록 안에는 예외가 발생했을 때 처리할 코드 작성
  - 예외가 발생하면 try를 빠져나와 except 블록으로 이동

### 복수 예외 처리
  #### 처리 순서
  1. 먼저 발생 가능한 에러가 무엇인지 예상
  2. 발생 가능한 에러를 모두 명시하거나 별도로 작성
     - 모두 명시 방법
      ```python
      try:
        pass
      except (ValueError, ZeroDivisionError):
        print('Error')
      ```
     - 별도 명시 방법
      ```python
      try:
        pass
      except ValueError:
        print('V_Error')
      except ZeroDivisionError:
        print('Z_Error')
      except:
        print('Error')
      ```

## 참고
### 예외 처리 주의사항
  #### 내장 예외의 상속 계층구조 주의
  - 내장 예외 클래스는 상속 계층구조를 가짐
  - **반드시 하위 클래스를 먼저 확인할 수 있도록 작성**해야 함

### 예외 객체 다루기
  #### as 키워드
  **예외 객체**
  - 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
  - except 블록에서만 예외 객체를 받아 상세한 예외 정보를 활용 가능

### EAFP & LBYL
예외처리와 값 검사에 대한 접근 방식
  #### EAFP
  예외처리를 중심으로 코드를 작성하는 접근 방식
  - `try-except`

  #### LBYL
  값 검사를 중심으로 코드를 작성하는 접근 방식
  - `if-else`

  #### 접근 방식 비교
  <div align = "center">

  |EAFP|LBYL|
  |:--:|:--:|
  |일단 실행하고 예외를 처리|실행하기 전에 조건을 검사|
  |코드를 실행하고 예외가 발생하면 예외처리를 수행|코드 실행 전에 예외 상황을 미리 검사하고 피하는 방식|
  |코드 작동 시간이 오래 걸릴 수 있음|코드가 더 길고 복잡해질 수 있음|
  |예외 상황을 예측하기 어려운 경우에 유용|예외 상황을 미리 방지하고 싶을 때 유용|
  </div>

## 자체 Q&A


## 공부 내용 돌아보기