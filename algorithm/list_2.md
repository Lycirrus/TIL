# List #2
## 2차원 배열
  #### Input 시 2차원 배열 생성
  ```python
  n = int(input)
  lst = [list(map(int, input().split())) for _ in range(n)]
  ```
  으로 한 줄로 들어오는 값을 2차원 배열 형태로 만들 수 있다.

  #### 지그재그 순회
  ```python
  for i in range(n):
    for j in range(m):
      lst[i][j + (m - 1 - 2 * j) * (i % 2)]

  # n = 3, m = 4일 경우
  for i in range(3):
    for j in range(4):
      lst[i][j + (3 - 2 * j) * (i % 2)]
  
  # 0행에서는 'i % 2 = 0'이 되므로 'lst[i][j]와 동일하다.
  # 1행에서는 'i % 2 = 1'이 되어 'lst[i][3 - j]로 작동한다.
  # 결국 홀수 행에서 열번호는 역순으로 돌게 되니, 지그재그로 순회하게 된다!
  ```

  #### 전치 행렬
  ```python
  for i in range(n):
    for j i range(n):
      if i < j:
        arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
  ```
  으로 전치행렬을 만들 수 있다.<br>
  `a, b = b, a`라는 파이썬만의 a와 b의 값을 교환하는 특별한 문법덕분에 간단하게 만들어졌다.<br>
  `i < j`라는 조건문이 없으면, 하나의 교환쌍에 대해 교환이 2번 일어나기에 원래대로 돌아가게 된다.
  `zip`을 이용하여 간단하게 만들 수 있다.
  ```python
  narr = list(zip(*arr))
  ```
  다만 내부는 튜플형이 되기에, 내부 리스트가 필요하다면 위의 방식을 고려할 수도 있을 것이다.

  > N * N 행렬에서 오른쪽 위를 향하는 대각의 요소를 구하는 방법<br>
  > 조건을 `i < j` 대신 `2 - i == j`로 하면 된다.<br>
  > 인덱스 i와 j의 합이 (N - 1)이 되는 요소만 뽑아내는 것이다.

## 부분집합 생성
`main_set = [1, 2, 3]`의 set형은 아니지만 집합이 있다고 하자.<br>
우선 해당 집합의 부분집합 개수는 '2^3'인 `8개`이다.

### 비트 검사
부분집합을 1과 0으로 표현하니 2진수를 보았다.


## 검색