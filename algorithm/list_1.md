# List #1
## 알고리즘
유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**
<br>문제를 해결하기 위한 절차

### 좋은 알고리즘
1. `정확성` : 얼마나 정확하게 동작하는가
1. `작업량` : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
1. `메모리 사용량` : 얼마나 적은 메모리를 사용하는가
1. `단순성` : 얼마나 단순한가
1. `최적성` : 더 이상 개선할 여지없이 최적화되었는가

### 시간복잡도 개요
알고리즘의 작업량을 표현할 때 시간복잡도로 표현한다.
- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산
  #### 빅-오(O) 표기법
  시간복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
  - 계수 생략

## 배열
일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
### 배열의 필요성
- 프로그램 내에서 여러 개의 변수가 필요할 때, 하나의 선언을 통해 둘 이상의 변수를 선언할 수 있다.
- 다수의 변수로는 하기 힘든 작업을 배열을 활용해 해결할 수 있다.

### 배열 선언
- 크기가 정해져 있는 배열을 사용하는 것이 좋다.
- `append`는 시간이 상당히 걸리는 작업<br>=> 자료가 많을 때는 사용하지 않는 것이 좋음

## 정렬
2개 이상의 자료를 특정 기준에 의해 오름차순, 또는 내림차순으로 재배열하는 것

### 정렬 방식 종류
- 버블 정렬
- 카운팅 정렬
- 선택 정렬
- 퀵 정렬
- 삽입 정렬
- 병합 정렬

### 버블 정렬
인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

  #### 정렬과정
  1. 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
    > 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.

  #### 시간복잡도
  `O(n^2)`

  #### 예시
  ![버블정렬 1단계](./image/bubble_step1.PNG)
  > 앞에서부터 두 개씩 비교한다.<br>
  > 앞 순서의 값이 더 큰 경우 뒤와 자리를 바꾼다.<br>
  > 앞이 더 작다면, 자리를 바꾸지 않는다.<br>
  > 비교했던 값 중 가장 큰값이 맨 뒤로 간다면 한 패스가 종료된다.<br>
  > 패스를 반복하여 오름차순(혹은 내림차순) 형태가 되면 종료된다.

  ```python
  def BubbleSort(a, N):
    for i in range(N - 1, 0, -1):
      for j in range(0, i):
        if a[j] > a[j + 1]:
          a[j], a[j + 1] = a[j + 1], a[j]
  ```

