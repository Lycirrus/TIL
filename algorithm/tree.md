# Tree
## 트리
### 트리의 개념
- 비선형 구조
  > 순서가 없음
- 원소들 간에 1:n 관계를 가지는 자료구조
- 원소들 간에 계층관계를 가지는 구조
- 상위 원소에서 하위 원소로 내려가면서 확장되는 모양의 구조

### 트리의 정의
한 개 이상의 노드로 이루어진 유한 집합이다.
- 최상위 노드는 '루트'라고 한다.
- 나머지 노드들은 n개의 분리 집합으로 나타낼 수 있다.
  > 분리 집합들은 각각 하나의 트리로 볼 수 있으며, 이를 `부 트리(subtree)`라고 한다.

### 트리의 용어
- 노드 : 트리의 원소
- 간선 : 노드를 연결하는 선
- 루트 노드 : 트리의 시작 노드
- 형제 노드 : 같은 부모 노드의 자식 노드들
- 조상 노드 : 한 노드에서 간선을 따라 루트 노드까지 이르는 경로의 모든 노드들
- 서브 트리 : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드 : 서브 트리에 있는 하위 레벨의 노드들
- 차수
  - 노드의 차수 : 노드에 연결된 자식 노드 수
  - 트리의 차수 : 노드의 차수 중 최대값
  - 리프 노드 : 자식 노드가 없는 노드
- 높이
  - 노드의 높이 : 루트에서 노드에 이르는 간선 수
  - 트리의 높이 : 노드의 높이 중 최대값

## 이진 트리
모든 노드들이 2개의 서브 트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대 2개까지 가질 수 있다.
- 왼쪽을 `왼쪽 자식 노드`, 오른쪽을 `오른쪽 자식 노드`라고 한다.

### 이진 트리 특성
- 레벨 i(높이가 i)에서의 최대 노드 개수는 `2^i`개 이다.
- 높이가 h인 이진 트리는 최소 `h + 1`개 에서 최대 `2^(h+1) - 1`개의 노드를 가질 수 있다.

### 이진 트리 종류
  #### 포화 이진 트리 (Full Binary Tree)
  - 높이가 h일 때, 최대 노드 개수 `2^(h+1) - 1`를 가진 이진 트리
  ![full-binary-tree](./image/FBT.PNG)

  #### 완전 이진 트리 (Complete Binary Tree)
  - 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 루트 노드부터 n번까지 빈 자리가 없는 이진 트리
  - ![complete-binary-tree](./image/CBT.PNG)
  
  #### 편향 이진 트리 (Skewed Binary Tree)
  - 높이 h일 때의 최소 노드 개수를 가지면서, 한쪽으로만 편향된 이진 트리
  - 선형 리스트와 동일하여 트리의 장점을 살리지 못함
  - 그래서 이를 해결하는 몇가지 알고리즘이 존재
    > 왼쪽 편향 트리

    ![left-skewed-binary-tree](./image/LSBT.PNG)

    > 오른쪽 편향 트리

    ![right-skewed-binary-tree](./image/RSBT.PNG)

## 이진 트리의 순회
트리의 각 노드를 중복되지 않게 전부 방문하는 것을 순회라고 한다.
- 그러나 비선형구조라 선후 연결 관계를 알수가 없기에 특별한 방법이 필요하다.
  
### 순회 방법
  #### 전위 순회(preorder traversal - VLR)
  부모노드 방문 후, 자식노드를 좌우 순서로 방문
  
  - 수행 방법
    
    1. 현재 노드 n을 방문하여 처리
    2. 현재 노드 n의 왼쪽 서브트리로 이동
    3. 현재 노드 n의 오른쪽 서브트리로 이동
    ```python
    def preorder_traverse(T):
      if T:
        visit(T)
        preorder_traverse(T.left)
        preorder_traverse(T.right)
    ```

  #### 중위 순회(inorder traversal - LVR)
  왼쪽 서브트리부터 이동하여 노드 방문

  - 수행 방법
  
    1. 현재 노드 n의 왼쪽 서브트리로 이동
    2. 현재 노드 n을 방문하여 처리
    3. 현재 노드 n의 오른쪽 서브트리로 이동
    ```python
    def inorder_traverse(T):
      if T:
        inorder_traverse(T.left)
        visit(T)
        inorder_traverse(T.right)
    ```

  #### 후위 순회 (postorder traversal - LRV)
  서브 트리들 먼저 확인하여 노드 방문

  - 수행 방법
    
    1. 현재 노드 n의 왼쪽 서브트리로 이동
    2. 현재 노드 n의 오른쪽 서브트리로 이동
    3. 현재 노드 n을 방문하여 처리
    ```python
    def postorder_traverse(T):
      if T:
        postorder_traverse(T.left)
        postorder_traverse(T.right)
        visit(T)
    ```

    #### 예시
    아래와 같은 이진 트리가 있을 때
    ![yesi](./image/yesi_tree.PNG)
    - 전위 순위
      > A B D H I E J C F K G L M
    - 중위 순위
      > H D I B J E A F K C L G M
    - 후위 순위
      > H I D J E B K F L M G C A



## 이진 탐색 트리
데이터들을 빠르게 검색할 수 있도록 체계적으로 저장하여, 최대 O(log n)의 빠른 속도로 값을 검색할 수 있는 자료구조
- 빠른 검색을 위해 특정 규칙을 갖는 이진트리 형태로 값을 저장한다.

### 동작 원리
1. 처음 등장하는 값은 root에 저장한다.
2. 그 다음 들어오는 값은 root와 비교하여 작으면 왼쪽 노드, 크면 오른쪽 노드에 배치한다.
3. 그 이후로는 경로 상의 노드와 비교하여 노드 값보다 작으면 왼쪽, 크면 오른쪽으로 진행한다.

### BST의 시간복잡도
최대 탐색 노드의 수는 `2^h - 1`이다. 1은 '2^h'에 비해 작은 수이므로 예외로하면, 개수 N은 2^h가 된다.<br>
이를 정리하면 `h = log N`이 되어, 시간복잡도가 O(log N)이 된다.
> 편향되있는 경우 노드의 수가 `h + 1`이므로, `h = N`이 된다. <br>따라서, 시간복잡도가 리스트와 동일하게 O(n)이 된다.<br>그래서 편향 이진 트리는 이진 트리 중 최악의 경우이다.

- 결국 BST의 탐색, 삽입, 삭제 시간은 트리의 높이와 비례관계에 있다.

### BST 순회
BST에서 중위순회를 하게 되면, 나온 결과가 오름차순이 된다.

### BST의 삭제 연산
- 삭제되는 값이 리프 노드라면 그냥 삭제한다.
- 중간 레벨에서 자식이 하나인 노드가 삭제된다면, 자기 자식을 자기 부모에 연결하고 삭제한다.
- 자식이 둘인 노드를 삭제할 때는 왼쪽 서브 트리의 가장 큰 값, 또는 오른쪽 서브트리의 가장 작은 값을 위치시키고 삭제한다.

## 힙
**완전 이진 트리**에 노드 중에서 키 값이 가장 크거나 작은 노드를 찾기 위한 자료구조
- 최대 힙(max heap)
  - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  - `부모 노드의 키값 > 자식 노드의 키값`
  - 루트 노드 : 키 값이 가장 큰 노드
- 최소 힙(min heap)
  - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  - `부모 노드의 키값 < 자식 노드의 키값`
  - 루트 노드 : 키 값이 가장 작은 노드

### 힙의 특징
완전 이진 트리로 구현된 자료구조로서, 키 값이 가장 큰 노드나 가장 작은 노드를 찾기에 적합하다.
- 힙의 키를 우선순위로 하여 '우선순위 큐'를 구현할 수 있다.

### 힙의 삽입과정
1. 완전 이진 트리를 유지시키면서 삽입할 자리를 확장한다.
2. 확장한 자리에 삽입 원소를 저장한다.
3. 부모와 비교하며 올바른 위치를 찾아준다.

### 힙에서의 삭제
- 힙에서는 루트 노드의 원소만을 삭제할 수 있다.
- 삭제된 원소는 반환된다.
> 이는 힙의 목적이 최대값 또는 최소값을 찾는 것이기 때문이다.

  #### 삭제 과정
  1. 루트 노드 원소를 삭제한다.
  2. 완전 이진 트리를 유지하기 위해 마지막 번호의 노드 원소를 루트로 이동시키고 삭제한다.
  3. 새로운 루트 노드 원소와 자식과 비교하며 자리를 바꾼다.
    > 다만 힙의 루트에는 원소 중 최대 혹은 최소값이 와야하기 때문에 자식들 중 큰 값 또는 작은 값과 비교하여 자리를 바꿔야 한다.

## 자체 Q&A