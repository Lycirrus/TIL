# SW 문제 해결 능력
## SW 문제 해결 역량
프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력

## 복잡도 분석
- 알고리즘
  - 유한한 단계를 통해 **문제를 해결**하기 위한 **절차**나 **방법**

### 알고리즘의 효율
- 공간적 효율성과 시간적 효율성
  - 공간적 효율성은 연산량 대비 얼마나 **적은 메모리 공간**을 요하는 가를 말한다.
  - 시간적 효율성은 연산량 대비 얼마나 **적은 시간**을 요하는 가를 말한다.
    > 복잡도(Complexity)가 높을수록 효율성은 저하된다.

### 복잡도의 점근적 표기
- 시간이나 공간 복잡도는 입력 크기에 대한 함수로 표기
    > 여러 개의 항을 가진 함수
- 단순히 나타내기 위해 점근적 표기를 사용

<div align="center">

|표기법 종류|의미|
|:--------:|:--:|
|`Big-Oh`|최대 시간|
|`Big-Omega`|최소 시간|
|`Big-Theta`|평균 시간|

</div>

> 코딩 테스트에서는 **항상 최악의 상황을 고려**해야 하므로,<br> Big-Omega와 Big-Theta는 크게 고려하지 않는다.
>
> 다만, 개발 환경에서는 모두 고려한다.

### O(Big-Oh)-표기
O-표기는 복잡도의 점근적 상한을 나타낸다.
> 복잡도가 `f(n) = 2n^2 - 7n + 4`라면 f(n)의 O-표기는 `O(n^2)`이다.
>
> 계수가 없으므로 대략적인 지표만 계산 가능하다.
>
> 그러나 미세하게 성능을 비교하고자 할 때 계수를 사용하기도 한다.

### 자주 사용하는 O-표기

<div align="center">

|표기|시간|
|:--------:|:--:|
|`O(1)`|상수 시간|
|`O(log n)`|로그(대수) 시간|
|`O(n)`|선형 시간|
|`O(n log n)`|로그 선형 시간|
|`O(n^2)`|제곱 시간|
|`O(n^3)`|세제곱 시간|

</div>

> **주의**
>> 로그의 밑은 10이 아닌 **2**이다.

### 효율적인 알고리즘이 필요한 이유
- 10억 개의 숫자를 정렬하는데 O(n^2) 알고리즘은 300여 년이 걸리는 반면 O(n log n) 알고리즘은 5분 만에 정렬한다.
- 따라서, 효율적인 알고리즘 개발이 훨씬 더 경제적이다.

## 표준 입출력
### 방법
```python
import sys
# 입력
sys.stdin = open("input.txt", "r")
## r은 읽기 모드로 열기
# 출력
sys.stdin = open("output.txt", "w")

n = int(input())
print(n)
```

## 진법
- 16진수 : 2진수를 더 가독성 있게 사용하기 위함
> 왜 16진수 인가?
>> 컴퓨터는 기본적으로 2진수를 사용한다.<br>
>> 그러나 `2진수`는 사람이 이해하기 어렵다.
>>
>> `10진수`는 사람이 이해하기는 좋으나 연산이 오래 걸린다.<br>
>> 그러나 `16진수`는 10진수만큼은 아니지만 2진수보다 사람이 이해하기 쉽고, 연산 속도 역시 매우 빠르다.

## 비트 연산
### 비트 연산자
- `&` (**AND**) : 앞뒤 모두 1일 때만 결과가 1이다.
- `|` (**OR**) : 앞뒤 둘 중 하나만 1이면 결과가 1이다.

> 비트 연산자 앞뒤의 숫자는 2진수로 변환하여 각 자리수를 비교한 뒤, 결과를 10진수로 출력한다.

> 2진수로 변환했을 때 자리수가 다르다면, 작은 수의 앞에 큰 수의 자리 수와 동일해질 때까지 0을 붙여 계산하는 느낌으로 진행한다.

- `^` (**XOR**) : 앞뒤의 숫자가 다를 때 1이다.
  > 어떤 값이던 특정 수로 2회 XOR 연산을 진행하면 원래 수로 돌아온다.
  >> 1. 7070 ^ 1004 = 6258
  >> 2. 6258 ^ 1004 = 7070
- `~` (**NOT**) : 모든 비트를 반전시킨다.
  > ~(0001 1111) = 1110 0000

  - 파이썬에서의 NOT 연산
    > ```python
    > print(~4) # 출력은 -5
    > ```
    > 1. 4는 `0b0100`이다.<br>
    > 1. NOT 연산자로 뒤집으면 `0b1011`이다.
    > 1. MSB가 1이므로 음수가 되어 나머지 비트 `011`에 보수를 취해준다.
    > 1. 100 + 1 = 101이므로 5가 된다.
    > 1. MSB가 1이므로, `-5`가 출력된다.
    >
    > 결국 0이상의 정수 n이 있을 때, `~n`을 출력하면 `-(n + 1)`이 나타났다.
    >> `print(~0) => -1`
    >> `print(~100) => -101`

- `<<` (**Left Shift**) : 특정 수 만큼 비트를 왼쪽으로 밀어낸다.
  > `print(bin(0b1 << 2)) # 0b100`
  >
  > 십진수로 표현하면, 연산자 뒤의 숫자만큼 왼쪽 수에 **2를 곱**하는 작업을 반복하는 것과 같다. 
- `>>` (**Right Shift**) : 특정 수 만큼 비트를 오른쪽으로 밀어낸다.
  > 밀려난 우측 비트들은 제거<br>
  > `print(bin(0b1101 >> 2)) # 0b11`
  >
  > 똑같이 십진수로 표현하면, 연산자 뒤의 숫자만큼 왼쪽 수에 **2로 나눈 몫**을 구하는 작업을 반복하는 것과 같다.

### 음수 표현 방법
컴퓨터는 음수를 "**2의 보수**"로 관리한다.
- 맨 앞자리 bit인 MSB는 음수나 양수를 구분하는 비트이다.
  > MSB가 0이면 양수, 1이면 음수이다.

  #### 2의 보수 사용 이유
  1. 뺄셈의 연산 속도 상승
  2. `+0`과 `-0`을 따로 취급하지 않기 위함
     > 1의 보수 방식은 0이 `1111`, `0000`의 두 방식으로 표현된다.

  #### 2의 보수 예시
  `10100`이 있을 때, (MSB는 생략)
  1. 수를 모두 뒤집는다.
     > `10100` => `01011`
  2. 1을 더한다.
     > `01011` + 1 = `01100` 

  - 1번까지만 진행하면 '1의 보수' 방식이 된다.
  - 어떤 2진수에 2의 보수를 두번 취하면, **원래 값으로 돌아온다**.

## 실수
### IEEE 754
컴퓨터에서 부동소수점을 표기하는 국제표준

  #### 부동 소수점
  **소수점의 위치를 고정**하여 표현
  - 소수점의 위치를 가장 왼쪽 유효숫자 다음으로 고정시키고 밑수의 지수승으로 표현
     > `1001.0011 => 1.0010011 * 2^3`

  #### 형식
  32bit 구조
  - 부호 1bit
    - 0이면 양수, 1이면 음수
  - 지수 8bit
    - 부동소수점의 크기 + bias 값
  - 가수 23bit
    - 실질적 수
  
  #### 예시
  12.375의 IEEE 754 표현
  1. 2진수로 변환
     > 12.375 => 1100.011
  2. 부동소수점 표현
     > 1100.011 => 1.100011 * 2^3
  3. 지수 부분
     > 3 + 127(bias) = 130<br>
     > 130의 2진수 변환 : `1000 0010`
  4. 가수 부분
     > `100 0110 0000 0000 0000 0000`<br>
     > 23자리로 표현<br>
     > 부동 소수점 이하 자리에 23자리가 될때까지 0을 붙임